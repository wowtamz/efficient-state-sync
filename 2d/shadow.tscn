[gd_scene load_steps=4 format=3 uid="uid://ddp6wlxjov6ll"]

[ext_resource type="Texture2D" uid="uid://g57nmh0fwuva" path="res://icon.svg" id="1_6pqxc"]

[sub_resource type="GDScript" id="GDScript_6pqxc"]
script/source = "extends Sprite2D

var states: Dictionary = {
	0: Color.WHITE,
	1: Color.RED,
	2: Color.GREEN,
	3: Color.BLUE,
	4: Color.YELLOW,
	5: Color.PINK
}

var id: int = 0

var state: int = 0 : set = set_state

var pos: Vector2 = position

var snapshots: Array[StateData] = []
var current_snapshot: StateData

var _latency: float = 0.2
var _packet_loss: float = 0.0

var _t_delta: int = 1

var _from_pos: Vector2 = position
var _to_pos: Vector2 = position

var _lerp: bool = false
var _step_factor: float = 1.0
var _last_time: int = 0
var _vel: Vector2 = Vector2()

var t: float = 0.0 ## Lerp progress

func _ready() -> void:
	set_process(true)

func set_lerp(val: bool) -> void:
	_lerp = val
	if val:
		t = 0.0

func _process(delta: float) -> void:
	process_lerp(delta)

func process_lerp(delta: float) -> void:
	if _lerp:
		var steps_per_frame = get_parent().send_rate * delta
		if t > 1.0:
			go_to_next_lerp_target()
		t += steps_per_frame * _step_factor
		position = _from_pos.lerp(_to_pos, t)

func update_target_pos(state: StateData) -> void:
	if state and state.get_value(StateData.TIME) > _last_time:
		var x = state.get_value(StateData2D.POS_X)
		var y = state.get_value(StateData2D.POS_Y)
		_to_pos = Vector2(x if x else position.x, y if y else position.y)
		_last_time = state.get_value(StateData.TIME)
	else:
		print(\"T_DELTA < 0\") # Jitter here!

func update_extrapolate_pos() -> void:
	_step_factor = 0.5
	_vel = (_to_pos - _from_pos)
	_to_pos += _vel

func go_to_next_lerp_target():
	t = 0.0
	_from_pos = position
	var next_state = null
	if snapshots.is_empty():
		_step_factor = 0.1
		update_extrapolate_pos()
		print(\"extrapolate\")
	elif snapshots.size() == 1:
		_step_factor = 0.75
		next_state = snapshots.pop_front()
		print(\"move towards latest\")
	else:
		next_state = snapshots.pop_at(snapshots.size() - 2)
		if next_state.get_value(StateData.TIME) > _last_time:
			_step_factor = float(next_state.get_value(StateData.TIME) - _last_time)
		print(\"move towards previous\")
	
	if next_state:
		update_target_pos(next_state)

func append_snapshot(n_snapshot: StateData) -> void:
	
	if snapshots.size() == 0: # Base case
		snapshots.append(n_snapshot)
		return
	
	if check_packet_time(snapshots.back(), n_snapshot):
		snapshots.append(n_snapshot)

func check_packet_time(last_state, new_state) -> bool:
	return last_state.get_value(StateData.TIME) < new_state.get_value(StateData.TIME) or (last_state.get_value(StateData.TIME) > 65000 and new_state.get_value(StateData.TIME) < 200)

func on_receive_packet(packet: PackedByteArray) -> void:
	if is_packet_lost(): # Simulate packet loss
		return
	var state_data: StateData = StateData2D.from_bytes(packet)
	var lat = _latency - randf_range(0.0, _latency)
	await get_tree().create_timer(lat).timeout
	$interpolate.on_new_snapshot(state_data)
	#if _lerp:
	#	append_snapshot(state_data)
	#else:
	#	sync_state(state_data)

func is_packet_lost() -> bool:
	if _packet_loss:
		var rand_val = randi_range(0, int(1.0 / _packet_loss) - 1)
		if rand_val == 0:
			return true
	return false

func sync_state(state_data: StateData) -> void:
	
	var pos_x = state_data.get_value(StateData2D.POS_X)
	var pos_y = state_data.get_value(StateData2D.POS_Y)
	var rot = state_data.get_value(StateData2D.ROT)
	var _state = state_data.get_value(StateData2D.STATE)
	
	if pos_x:
		position.x = pos_x + (get_viewport_rect().size.x / 2) - 64
	if pos_y:
		position.y = pos_y
	if rot:
		rotation = rot
	if _state:
		state = _state

func set_state(new_state: int) -> void:
	modulate = states[new_state]

func set_latency(ms: float) -> void:
	_latency = ms / 1000.0

func set_packet_loss(val: float) -> void:
	_packet_loss = val
"

[sub_resource type="GDScript" id="GDScript_bbwug"]
script/source = "extends Node

var _pos_buffer: Array

var _start_pos: Vector2
var _end_pos: Vector2

#var _last_tick: int = 0
var _lerp_progress: float = 0.0
var _lerp_factor: float = 1.0

func _ready() -> void:
	set_process(false)

func _process(delta: float) -> void:
	
	if _lerp_progress > 1.0:
		go_to_next_lerp_pos()
	
	var packets_per_sec: float = get_parent().get_parent().send_rate
	var frames_per_sec: float = 1.0 / delta
	var steps_per_frame: float = packets_per_sec / frames_per_sec  # 1.0 / ((1.0 / packets_per_sec) / delta) #
	print(\"steps: \",  steps_per_frame)
	print(\"factor: \", _lerp_factor)
	_lerp_progress += steps_per_frame * _lerp_factor
	get_parent().position = _start_pos.lerp(_end_pos, _lerp_progress)

func go_to_next_lerp_pos() -> void:
	_lerp_progress = 0.0
	_start_pos = get_parent().position
	
	var next_pos = null
	
	if _pos_buffer.is_empty():
		print(\"extrapolate 1\")
	elif _pos_buffer.size() == 1:
		print(\"extrapolate 2\")
	elif _pos_buffer.size() == 2: # _pos_buffer.size() > 1
		print(\"interpolate 1\")
	else:
		var old_state = _pos_buffer.pop_front()
		var next_state = _pos_buffer.pop_front()
		_start_pos = get_pos(old_state)
		_end_pos = get_pos(next_state)
		_lerp_factor = get_tick(next_state) - get_tick(old_state)

func set_next_lerp_target(pos: Vector2) -> void:
	pass

func on_new_snapshot(state_data: StateData) -> void:
	
	var prev_t = get_tick(_pos_buffer.back()) if not _pos_buffer.is_empty() else 0
	var t = state_data.get_value(StateData.TIME)
	
	if t > prev_t or (t < 100 and prev_t > 65000):
		var x = state_data.get_value(StateData2D.POS_X)
		var y = state_data.get_value(StateData2D.POS_Y)
		_pos_buffer.append(
			[t, Vector2(x if x else get_parent().position.x, y if y else get_parent().position.y)]
		)
	
	if _pos_buffer.size() > 2:
		set_process(true)

func get_tick(array: Array) -> int:
	return array.get(0)

func get_pos(array: Array) -> Vector2:
	return array.get(1)
"

[node name="shadow" type="Sprite2D" groups=["shadow"]]
modulate = Color(1, 1, 1, 0.596078)
self_modulate = Color(1, 1, 1, 0.529412)
scale = Vector2(0.5, 0.5)
texture = ExtResource("1_6pqxc")
script = SubResource("GDScript_6pqxc")

[node name="interpolate" type="Node" parent="."]
script = SubResource("GDScript_bbwug")
