[gd_scene load_steps=4 format=3 uid="uid://ddp6wlxjov6ll"]

[ext_resource type="Texture2D" uid="uid://g57nmh0fwuva" path="res://icon.svg" id="1_6pqxc"]

[sub_resource type="GDScript" id="GDScript_6pqxc"]
script/source = "extends Sprite2D

var states: Dictionary = {
	0: Color.WHITE,
	1: Color.RED,
	2: Color.GREEN,
	3: Color.BLUE,
	4: Color.YELLOW,
	5: Color.PINK
}

var id: int = 0

var state: int = 0 : set = set_state

var pos: Vector2 = position

var snapshots: Array[StateData] = []
var current_snapshot: StateData

var _latency: float = 0.2
var _packet_loss: float = 0.0

var _lerp: bool = true

func _ready() -> void:
	set_process(true)

func set_lerp(val: bool) -> void:
	_lerp = val
	$interpolate.set_process(val)

func on_receive_packet(packet: PackedByteArray) -> void:
	if is_packet_lost(): # Simulate packet loss
		return
	var state_data: StateData = StateData2D.from_bytes(packet)
	var lat = _latency - randf_range(0.0, _latency)
	await get_tree().create_timer(lat).timeout
	if _lerp:
		$interpolate.on_new_snapshot(state_data)
	else:
		sync_state(state_data)

func is_packet_lost() -> bool:
	if _packet_loss:
		var rand_val = randi_range(0, int(1.0 / _packet_loss) - 1)
		if rand_val == 0:
			return true
	return false

func sync_state(state_data: StateData) -> void:
	
	var pos_x = state_data.get_value(StateData2D.POS_X)
	var pos_y = state_data.get_value(StateData2D.POS_Y)
	var rot = state_data.get_value(StateData2D.ROT)
	var _state = state_data.get_value(StateData2D.STATE)
	
	if pos_x:
		position.x = pos_x + (get_viewport_rect().size.x / 2) - 64
	if pos_y:
		position.y = pos_y
	if rot:
		rotation = rot
	if _state:
		state = _state

func set_state(new_state: int) -> void:
	modulate = states[new_state]

func set_latency(ms: float) -> void:
	_latency = ms / 1000.0

func set_packet_loss(val: float) -> void:
	_packet_loss = val
"

[sub_resource type="GDScript" id="GDScript_bbwug"]
script/source = "extends Node

var _pos_buffer: Array
var _rot_buffer: Array

var _start_pos: Vector2
var _end_pos: Vector2

var _last_tick: int = 0
var _lerp_progress: float = 0.0
var _lerp_factor: float = 1.0
var _lerp_limit: float = 1.0

var _lerp_angle_progress: float = 0.0
var _lerp_angle_speed: float = 1.0
var _start_angle: float
var _end_angle: float

func _ready() -> void:
	set_process(false)

func _process(delta: float) -> void:
	
	if _lerp_progress >= _lerp_limit:
		get_next_state()
		#go_to_next_lerp_pos()
	
	if _lerp_angle_progress >= 1.0:
		get_next_rot()
	
	var packets_per_sec: float = get_parent().get_parent().send_rate
	var frames_per_sec: float = 1.0 / delta
	var steps_per_frame: float = packets_per_sec / frames_per_sec
	
	_lerp_progress += steps_per_frame * _lerp_factor
	_lerp_progress = clamp(_lerp_progress, 0.0, _lerp_limit)
	assert(_lerp_progress <= _lerp_limit)
	get_parent().position = _start_pos.lerp(_end_pos, _lerp_progress)
	
	_lerp_angle_progress += steps_per_frame * _lerp_angle_speed
	get_parent().rotation = lerp_angle(_start_angle, _end_angle, _lerp_angle_progress)

func begin_lerp_to(pos: Vector2, duration: float) -> void:
	_lerp_progress = 0.0
	_start_pos = get_parent().position
	_end_pos = pos

func get_next_state() -> void:
	
	_lerp_progress = 0.0
	_start_pos = get_parent().position
	
	var next_state = null
	
	var n = _pos_buffer.size()
	
	if _pos_buffer.is_empty():
		_lerp_progress = 1.0
		print(\"waiting for state\")
		return
	elif n >= 1 and n <= 2:
		_lerp_factor = 0.25
		next_state = _pos_buffer.pop_front()
	elif n == 3:
		_lerp_factor = 0.8
		next_state = _pos_buffer.pop_front()
	else:
		var index = n - 3
		next_state = _pos_buffer.pop_at(index)
		_lerp_factor = 1.0 / float(abs(get_tick(next_state) - _last_tick) % 65536)
		# Erase previous states
		for i in range(index):
			_pos_buffer.pop_front()
	
	if next_state:
		_last_tick = get_tick(next_state)
		_end_pos = get_pos_array(next_state) + Vector2((get_parent().get_viewport_rect().size.x / 2) - 64, 0)

func get_next_rot() -> void:
	_lerp_angle_progress = 0.0
	_start_angle = get_parent().rotation
	
	var next_state = null
	
	var n = _rot_buffer.size()
	
	if _rot_buffer.is_empty():
		_lerp_progress = 1.0
		return
	elif n >= 1 and n <= 2:
		_lerp_angle_speed = 0.25
	elif n == 3:
		_lerp_angle_speed = 0.8
	else:
		var index = n - 3
		next_state = _rot_buffer.pop_at(index)
		_lerp_factor = 1.0 / float(abs(get_tick(next_state) - _last_tick) % 65536)
		# Erase previous states
		for i in range(index):
			_rot_buffer.pop_front()
		
	if next_state:
		_last_tick = get_tick(next_state)
		_end_angle = get_rot_array(next_state)

func on_new_snapshot(state_data: StateData) -> void:
	var prev_t = get_tick(_pos_buffer.back()) if not _pos_buffer.is_empty() else -1
	var t = state_data.get_value(StateData.TIME)
	
	if t > prev_t or (t < 100 and prev_t > 65000):
		_pos_buffer.append(
			[t, get_pos_state_data(state_data)]
		)
		
		_rot_buffer.append(
			[t, get_rot_state_data(state_data)]
		)
	
	# Set initial position
	if not is_processing() and _pos_buffer.size() > 2:
		print(\"initialized position\")
		var init_pos = _pos_buffer.pop_front()
		var init_rot = _rot_buffer.pop_front()
		var pos = get_pos_array(init_pos)
		var rot = get_rot_array(init_rot)
		set_parent_pos(pos)
		set_parent_rot(rot)
		set_process(true)

func set_parent_pos(vec: Vector2) -> void:
	get_parent().position = vec

func set_parent_rot(val: float) -> void:
	get_parent().rotation = val

func get_pos_state_data(data: StateData) -> Vector2:
	var x = data.get_value(StateData2D.POS_X)
	var y = data.get_value(StateData2D.POS_Y)
	return Vector2(x if x else get_parent().position.x, y if y else get_parent().position.y)

func get_rot_state_data(data: StateData) -> float:
	var val = data.get_value(StateData2D.ROT)
	return val if val else get_parent().rotation

func get_tick(array: Array) -> int:
	return array.get(0)

func get_pos_array(array: Array) -> Vector2:
	return array.get(1)

func get_rot_array(array: Array) -> float:
	return array.get(1)
"

[node name="shadow" type="Sprite2D" groups=["shadow"]]
modulate = Color(1, 1, 1, 0.596078)
self_modulate = Color(1, 1, 1, 0.529412)
scale = Vector2(0.5, 0.5)
texture = ExtResource("1_6pqxc")
script = SubResource("GDScript_6pqxc")

[node name="interpolate" type="Node" parent="."]
script = SubResource("GDScript_bbwug")
